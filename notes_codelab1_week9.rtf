{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs22\lang9 CODE LAB 1 - WEEK 9 - INTRO TO DATA STRUCTURES\par

\pard\sa200\sl276\slmult1 >We've been using arrays and lists up to this point... but we'll be delving into other cool data structures. An overview of the most common data structures. \line\line Powerpoint URL : {{\field{\*\fldinst{HYPERLINK https://github.com/madparker/Codelab1-S21-ClassCode/blob/main/Data%20Structures%20Slides.pdf }}{\fldrslt{https://github.com/madparker/Codelab1-S21-ClassCode/blob/main/Data%20Structures%20Slides.pdf\ul0\cf0}}}}\f0\fs22\line\line >What is a data structure? \par
\tab -Data structures are the we store and retrieve data. (lists and arrays come to mind) \line\tab\tab -Lists are more flexible than arrays. \line\tab\tab -Arrays are efficient, less complicated, and faster. \line\line\tab -Data stuctures provide two things: clarity and performance.\line\line\tab -Data structures handle four things:\tab\tab\par
\tab\tab -Inputting information\line\tab\tab -Processing information\line\tab\tab -Maintaining information\line\tab\tab -Retrieving information \line\line >Abstract Data Types (in C#)\line\line\tab -Lists\line\tab -2D Arrays\line\tab -Dictionary\line\tab -Queue\line\tab -Stack \par
>REMINDER: A TextAsset is another way of getting data into your program.\par
\tab\tab public InputField input; //input \line\tab\tab public TextAsset textFilewithNames; //shows up on inspector, list of names\line\tab\tab public Text display; //shows the text once we get it \par
\tab\tab private List<string> names; \line\line ^What kind of data are we putting into our list? A string.\par
>Make a new list of strings for the Start function\line\tab\tab\line\tab\tab private void Start()\line\tab\tab\{\line\tab\tab\tab names = new List<string>(); \line\tab\tab\tab //creates/instantiates the list \line\line\tab\tab\tab var namesFromFile = textFileWithName.text.Split('\\n');\line\tab\tab\tab //then we can start to read from our list of strings \line\tab\tab\tab //reads text and splits it into lines \line\tab\tab\tab //namesFromFile is an array \line\tab\tab\tab //alternatively, you can use string[] as opposed to var\line\tab\tab\tab\line\tab\tab\tab for (var i = 0; i < namesFromFile.Length; i++)\line\tab\tab\tab\{\line\tab\tab\tab\tab names.Add(namesFromFile[i].ToUpper());\line\tab\tab\tab\}\line\tab\tab\tab\line\tab\tab\tab ^for-loop will loop through every single name in text file\line\tab\tab\tab ^once it gets each name out of the string, then it adds it to \line\tab\tab\tab the list\line\tab\tab\tab ^ToUpper makes it all the names upper-case. \line\tab\tab\tab\line >There's LOTS of names in the listOfNames.txt, isn't there? But that's okay, it doesn't care - you can keep adding more and more names to because it is VERY STRONG. \par
\par
\tab\tab //extra method tests:\line\line\tab\tab Debug.Log("Count: " + namesList.Count); \line\tab\tab Debug.Log("Names contain \\"JACK\\":" + namesLIst.Contains("JACK")); \line\tab\tab Debug.Log("Names contains \\"LANNI\\":" + namesList.Contains("LANNI")); \par
\tab\tab ^Oh, how convenient! The first debug shows the number of names in the list. \line\tab\tab ^The second debug log shows if the name Jack is in the list.\line\tab\tab ^The third debug log shows if the name Lanni is in the list. \line\tab\tab ^This is much more simple than array, where we'd have to check each \line\tab\tab individual cell and make a for-loop for all the names. \par
\tab\tab names.Insert(4520, "LANNI"); \line\line\tab\tab ^We can also have multiple elements of the same name. We Insert the\line\tab\tab name Lanni into our list, so now there are TWO Lanni's. Which shows\line\tab\tab that we can have repeats and thats okay! You can have the same field\line\tab\tab multiple times.\par
\tab\tab var indexOfLastLanni = 0; \line\tab\line\tab\tab for (int i = 0; i < names.Count; i++)\line\tab\tab\{\line\tab\tab\tab if (names[i] == "LANNI")\line\tab\tab\tab\tab indexOfLastLanni = i;\line\tab\tab\}\line\line\tab\tab ^We go through this for-loop and want the last index of it. Let's\line\tab\tab\i find\i0  where Lanni is in this text. This is also how you would go through\line\tab\tab a list. Very similar to how you would go through an array, but instead\line\tab\tab of saying names.Length, we say names.Count. \line\tab\tab\tab -Once we get to Lanni, we set the index = i. \line\line\tab\tab Debug.Log(names[4520]); \line\tab\tab names.RemoveAt(indexOfLastLanni); \line\tab\tab Debug.Log(names[4520]); \line\line\tab\tab ^Print out the name Lanni which is #4520 in the list, because we Inserted\line\tab\tab that name there. \line\tab\tab ^We can also REMOVE that instance, which will replace it to another name,\line\tab\tab which is Tabatha.\line\tab\par
\tab\tab private void Update()\line\tab\tab\{\line\tab\tab\tab if (input.text == "") //if there's nothing in text box, show instructions\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Type a name to see if it's in the list!";\line\tab\tab\tab\}\tab\line\tab\tab\tab else //otherwise, check to see if the name is on the list...\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Not in the list."; //set display to say "not in list"\line\tab\tab\tab\line\tab\tab\tab\tab for (int i = 0; i < names.Count; i++) //loop through list\line\tab\tab\tab\tab\{\tab\line\tab\tab\tab\tab\tab if (input.text.ToUpper() = names[i]) //if names match\line\tab\tab\tab\tab\{\line\tab\tab\tab\tab\tab display.Text = "In the list!"; //say it's in the list\line\tab\tab\tab\tab\}\line\tab\tab\tab\}\line\tab\tab\} \line\tab\tab\tab\tab\par
\tab\tab ^If it's equal to nothing, display the text, "type a name..."\line\tab\tab ^But if there IS text in the text box, the default will be "not in the list."\line\tab\tab ^Make a for-loop that goes through all of the names. \line\tab\tab ^ToUpper will capitalize the letter if the name is on the list. \line\tab\tab ^And if it is on the list, it will  display the text, "in the list!" \par
>There is an easier way to do this. \par
\tab\tab private void Update()\line\tab\tab\{\line\tab\tab\tab if (input.text == "")\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Type a name to see if it's on the list!"; \line\tab\tab\tab\}\line\tab\tab\tab else\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Not in the list."; //set display to say "not in list" \line\tab\tab\tab\line\tab\tab\tab\tab if (namesList.Contains(input.text.ToUpper().Trim()))\line\tab\tab\tab\tab\{\line\tab\tab\tab\tab\tab display.text = "This Name is in the list!"; \line\tab\tab\tab\tab\}\line\tab\tab\}\par
>Go change Line 27 to add Trim. \line\line\tab\tab namesList.Add(namesFromFile[i].ToUpper().Trim()); \line\tab\tab\}\par
\tab\tab ^Adding the Trim gets rid of any spaces or unecessary things that might\line\tab\tab cause problems. \line\line >Use good naming conventions! This is a reminder.\line\line >Stack: grabs stuff on the top. A stack is first in, last out (LIFO). You get the top of the stack first. Last In, First Out (LIFO). A stack of plates is also an apt example. You wouldn't pull the one from the middle, would you? It would break the plates. You have to get the one on top. \line\line >The last one in, is the first one out. \line\tab\line\tab\tab public class StackExample : Monobehaviour\line\tab\tab\{\line\tab\tab\tab private Stack<string> effects = new Stack<string>();\line\tab\tab\tab //a different type of data structure\line\tab\tab\tab //a deck of playing cards can be like a stack\line\line\tab\tab\tab public Text display; //displays text\line\line\tab\tab\tab private float timer = 0; //this var keeps track how much time has gone\line\tab\tab\tab private float timePerTurn = 5; amount of time that exists before stop\line\tab\line\tab\tab\}\line\tab\tab\line\tab\tab private void Update() \line\tab\tab\{\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.Space))\line\tab\tab\tab\{\line\tab\tab\fs22\tab\tab\fs20 SceneManager.LoadScene(SceneManger.GetActiveScene().buildIndex); \fs22\tab\line\tab\tab\tab\}\line\tab\tab\tab\line\tab\tab\tab ^enables a quick reload of the scene. \line\tab\tab\tab\line\tab\tab\tab if (timer > timePerTurn) return; //if move takes more than 5 secs, cont\line\tab\tab\tab\line\tab\tab\tab ^return in this context means to just leave this function. don't worry \line\tab\tab\tab abt the rest of the code below. nifty lil' shortcut.\line\line\tab\tab\tab timer += Time.deltaTime; //increasing timer\line\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.A)) //if you press a\line\tab\tab\tab\{\line\tab\tab\tab\tab effects.Push("RESOLVE: Abigail casts Firebolt."); //\fs17 get this string\line\fs22\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.S)) //if you press s\line\tab\tab\tab\{\line\tab\tab\tab\tab effects.Push("RESOLVE: Sam casts Delay."); \line\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.D)) //if you press d\line\tab\tab\tab\{\line\tab\tab\tab\tab effects.Push("RESOLVE: Diana casts Portcullis."); \line\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.F)) //if you press f \line\tab\tab\tab\{\line\tab\tab\tab\tab effects.Push("RESOLVE: Frank casts Yam Sandwich.");\line\tab\tab\tab\}\line\line\tab\tab\tab ^^if you press A, S, D, or F, push that move into the stack.\line\line\tab\tab\tab if (timer >= timePerTurn) //if the timer is up\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Time is up!\\n"; //say time is up\line\tab\tab\tab\tab\line\tab\tab\tab\tab ShowStackEffects(); //show the effects\line\tab\tab\tab\}\line\tab\tab\tab else //otherwise...\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = (timePerTurn - timer).ToSTring("F2");\line\tab\tab\tab\tab //display timer \line\tab\tab\tab\}\line\tab\tab\tab\line\tab\tab\tab ^Formatting it to F2 just shows 2 digits on the timer.\line\tab\tab\tab ^If you omit the "F2" it'll show more digits on the timer. GROSS\line\tab\tab\tab ^If you want to show one digit - "F1"\line\line\tab\tab private void ShowStackEffects()\line\tab\tab\{\line\tab\tab\tab while (effects.Count > 0) //if effects is greater than 0 \line\tab\tab\tab\tab display.text += "\\n" + effects.Pop(); //display \line\tab\tab\}\line\tab\tab\tab\line\tab\tab\tab ^while there are effects in the stack, pop them out and show them\line\tab\tab\tab ^Pop shows and takes out what is on top of your stacc. lol stacc\line\tab\tab\tab ^PUSH.. and POP. this feels like a community reference \line\tab\tab -Why are we using while? It's like a for-loop that happens while your count\line\tab\tab is greater than 0. \line\tab\tab -You have to be careful with this - if you write this wrong, you'll have an \line\tab\tab infinite loop. BE. VERY. CAREFUL!!!\line\line >Queue: A queue is a first in, first out. (FIFO) First to come in, first to leave. british much\line\line\tab\tab public class QueueExample : MonoBehaviour \line\tab\tab\{\line\tab\tab\tab private Queue<string> fishQueue = new Queue<string>(); //string\line\line\tab\tab\tab public Text display; //displays text\line\line\tab\tab\tab private float timer = 0; //how much time has gone by\line\tab\tab\tab private float timePerTurn = 5; //how much time you have \par
\tab\tab private void Update()\line\tab\tab\{\line\tab\tab\tab if (Input.GetKeyDown.(KeyCode.Space)) //pres space\line\tab\tab\tab\{\line\tab\tab\tab\tab\fs16 SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); \fs22\line\tab\tab\tab\}\tab\line\tab\tab\tab\line\tab\tab\tab ^reload the scene - easy to restart!\line\line\tab\tab\tab if (timer > timePerTurn) return; //more than 5 secs, continue\line\line\tab\tab\tab timer += Time.deltaTime; //increase timer\line\tab\tab\tab\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.A)) //press a\line\tab\tab\tab\{\line\tab\tab\tab\tab fishQueue.Enqueue("Angel Fish");  //move to queue\line\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.S)) //press s \line\tab\tab\tab\tab fishQueue.Enqueue("Sailfish"); \line\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.D)) //press d\line\tab\tab\tab\tab fishQueue.Enqueue("Dartfish"); \line\tab\tab\tab\}\line\tab\tab\tab if (Input.GetKeyDown(KeyCode.F)) //press f\line\tab\tab\tab\tab fishQueue.Enqueue("Flounder"); \line\tab\tab\tab\}\line\line\tab\tab\tab ^If you press A, S, D, or F, push that and move to queue. \line\tab\tab\tab\line\tab\tab\tab if (timer >= timePerTurn) //if time is up\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = "Time is up!\\n"; //say time is up\line\line\tab\tab\tab\tab ShowQueueEffects(); //show the effects\line\tab\tab\tab\}\line\tab\tab\tab else //otherwise\line\tab\tab\tab\{\line\tab\tab\tab\tab display.text = (timePerTurn - timer).ToString("F2"); \fs16 //show timer\line\fs22\tab\tab\tab\}\line\tab\tab\}\par
\tab\tab private void ShowQueueEffects() //function\line\tab\tab\{\line\tab\tab\tab while (fishQueue.Count > 0) //\line\tab\tab\tab\tab display.text += "\\n" + fishQueue.Dequeue(); \line\tab\tab\}\line\tab\tab\line\tab\tab ^If the queue itself has more than 0 items, then add to the displaytext\line\tab\tab the next item in the queue and "dequeues" it. \line\tab\tab ^Makes sure the it doesn't go into infinity mode. \line\tab\tab ^Alternatively, you can use Peek as opposed to DeQueue. It will\line\tab\tab give you the item but will NOT take it off from the queue... but \line\tab\tab this will be infinity again. \par
>Queues and Stacks are very similar - a Stack is LIFO (Last In, First Out). \line >A Queue is FILO (First In, Last Out). Fun!\line\line >DICTIONARY. Yet another data structure. A unique key-value relationship. \line\tab (who hates oranges???) \line >A dictionary is a way to match a string (a word), to another string (the definition).\line\tab i.e - GEMS -> A number. \line >Mapping from one thing to another. From a number to a value. Think of how an array works.\line\tab Array slot [0] = A in the Alphabet. Array slot [1] = B in the Alphabet. And so on... \line\line >In an array, the key is always a number. And you have a value associated with that.\line >But with a dictionary, the key can be associated with ANYTHING. Including values. \line\line\tab\tab public class DictionaryExample : MonoBehaviour\line\tab\tab\{\line\tab\tab\tab public Text display; //displays text\line\line\tab\tab public void Update()\line\tab\tab\{\line\tab\tab\tab DisplayResources(); \fs21 //each update, display resources to player\fs22\line\tab\tab\tab DisplayItems(); //displays what items player has already\tab\tab\tab\tab\}\line\tab\tab\line\tab\tab\fs21 private Dictionary<string, int> resourcesOwned = new Dictionary<string, int>(); \line\tab\tab //represents what resources they have\fs22\line\tab\tab private Dictionary<string, int> itemsOwned = new Dictionary<string, int>(); \line\tab\tab //represents what items they have \line\line\tab\tab ^^These are both Dictionaries. The key is a string, and the value is int. \line\tab\tab ^You are mapping a string to an integer. They are separated by commas\line\tab\tab because when ur creating a Dictionary ur not only specifying what kind\line\tab\tab of thing you're putting into it, you're also specifying what kind of key\line\tab\tab -When you're making a list, all you need to know is the string bc you know\line\tab\tab the key to that is a number.\line\tab\tab -But when you're making a Dictionary, you have to specify the KEY (string)\line\tab\tab and VALUE (int). \line\tab\tab\line\tab\tab public void AddResources(string resourceType, int amountToAdd) \line\tab\tab //this function adds a resource. we have a string and an amount. \line\tab\tab //string: resourceType. amount. \line\tab\tab\{\line\tab\tab\tab if (resourcesOwned.ContainsKey(resourceType))\line\tab\tab\tab //resourcesOwned is the name of your dict\line\tab\tab\tab //checking to see if it contains a key (resourceType)\line\tab\tab\tab //do you already have a key with this name? if so...\line\tab\tab\tab\{\line\tab\tab\tab\tab\fs15 resourcesOwned[resourceType] = resourcesOwned[resourceType] + amountToAdd; \line\tab\tab\tab\tab //you're putting a string bc you set your index to be a string and not an int \line\tab\tab\tab\tab //set gem to what is ALREADY inside of resourceType + amountToAdd. \line\tab\tab\tab\tab //you can also do += if you wish . big brained \line\fs22\line\tab\tab\tab\tab\fs15 Debug.Log("You own" + resourcesOwned[resourceType] = " of " + resourceType); \fs14\line\fs22\tab\tab\tab\}\line\tab\tab\tab else //If it's NOT/Otherwise \line\tab\tab\tab\{\line\tab\tab\tab\tab resourcesOwned.Add(resourceType, amountToAdd); \line\tab\tab\tab\tab //add it to your dictionary, give it a value \line\tab\tab\tab\tab //if you haven't had any gems in your resources prior,\line\tab\tab\tab\tab you're adding it here \line\tab\tab\tab\}\par
>Let's jump to the DisplayResources function\line\tab\tab\line\tab\tab public void DisplayResources() //displays owned resources\line\tab\tab\{\line\tab\tab\tab display.text = "Owned Resources:\\n"; \line\tab\tab\tab\line\tab\tab\tab foreach (KeyValuePair<string, int> keyValuePair in resourcesOwned)\line\tab\tab\tab\{\line\tab\tab\tab\tab\fs16 display.text += "\\n" + keyValuePair.Key + " (" + resourcesOwned[keyValuePair.key] + ")"; \fs22\line\tab\tab\tab\}\line\tab\tab\}\line\tab\line\tab\tab ^What the heckie is that foreach loop???\line\tab\tab >foreach - what is the in the 0 slot of Resourcesowned? There are no slots,\line\tab\tab only Resources - and not in any specific order. This also is because there\line\tab\tab are TWO things we are looking for -a string and value. \line\tab\tab ^This will decide on it's own order. If you don't care about the #, then\line\tab\tab you can use this. If you do, then use a for-loop. \line\line >Will cover more on Dictionaries and 2DArrays next lesson.\line >Rehash: Dictionaries can be used for everything! Dictionary from floats, ints, ScriptableObjects, strings, etc. \line >Let's say you look up the word \i bat\i0 . There are multiple definitions for \i bat\i0 , right? An animal, trying to hit something, a sports stick, something you do with your eyelashes... etc. \line >A dictionary goes from a string to an array, or a list. You can combine these different data structures together to make more robust data structures! VERY COOL. \line\line HW: Make something that uses a stack or a queue. When you put things on, or take things off, something happens... will you take the course of the FIFO? Or the LIFO? Both? \par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
}
 